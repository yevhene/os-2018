# Знайомство з основними механізмами реалізації технології "клієнт-сервер" в ОС Unix, робота з неіменованими каналами

## Основні положення

### Мета
Ознайомити з основними механізмами реалізації новітніх технологій ("клієнт-сервер"), розбір програми роботи з неіменованими каналами.

### Завдання
Розробити програму що зчитує файл та передає його вміст іншій команді, за допомогою неіменованого каналу.

## Матеріали

### Аргументи командного рядка
```c
int main(int argc, char *argv[])
```
Аргументи:
1. `argc` - кількість аргументів;
2. `argv` - перелік аргументів.

### Завершення програми
```c
exit(1)
```
Аргументи:
1. Код що буде повернено операційній системі. `0` - успішне завершення. В іншому випадку аварійне.

Необхідно включити `stdlib`:
```c
#include <stdlib.h>
```

### Робота з файлами

#### Відкриття
```c
fopen("file.txt", "r")
```
Аргументи:
1. Ім'я файла;
2. Режим роботи з файлом:
  - r - читання;
  - w - запис;
  - t - нестандартна опція, відмічає файл, як текстовий.

Повертає:
Дескриптор файла для подальшої роботи. Або `NULL` у випадку помилки.

#### Закриття
```c
fclose(file)
```
Аргументи
1. Дескриптор файла.

#### Зчитування рядка з файла
```c
fgets(buff, 80, file)
```
Аргументи:
1. Буфер, у який відбудеться зчитування;
2. Максимальна довжина рядка;
3. Дескриптор файла.

#### Запис рядка у файл
```c
fputs(buff,file)
```
Аргументи:
1. Буфер, у який відбудеться зчитування;
2. Дескриптор файла.

#### Перевірка на кінець файла
```c
feof(file)
```
Аргументи:
1. Дескриптов файла.
Повертає:
`true` - якщо зчитування за дескриптором добігло кінця файла.

#### Форматований запис у файл
```c
fprintf(file, "Hello %s", "Vasyl")
```
Аргументи:
1. Дескриптор файла;
2. Форматний рядок;
3. Подальші аргументи - підстановки у форматний рядок.

### Робота з потоками вводу/виводу/помилки
Потоки вводу/виводу/помилки у Linux представлені файлами
:
- `stdin` - ввод;
- `stdout` - вивід;
- `stderr` - вивід помилок.
У кожній програмі об'явлені відповідні константи. Працювати з ними можна, як зі звичайними файловими дескрипторами:
```
fprintf(stderr, "USAGE: popen3 [command] [filename]\n");
```

### Робота з неіменованими каналами (pipes)
Дуже подібна до роботи з файлами. Використовуються ті ж самі команди: `fgets`/`fputs`. Відрізняється тільки процесс відкриття і закриття.

#### Запуск підпроцесу та створення неіменованого каналу пов'язаного з ним
```c
popen("cat", "w")
```
Аргументи:
1. Команда;
2. Режим роботи з неіменованим каналом:
  - r - читання;
  - w - запис.

Повертає:
Дескриптор каналу для подальшої роботи. Або `NULL` у випадку помилки.

#### Закриття неіменованого каналу
pclose(pipe);

## Приклад роботи програми
```
$ ./main head main.c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  FILE *pipe_fp, *infile;
  char readbuf[80];
  if (argc != 3) {
    fprintf(stderr, "USAGE: popen3 [command] [filename]\n");
    exit(1);
```

## Приклад лістингу
```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  FILE *pipe_fp, *infile;
  char readbuf[80];
  if (argc != 3) {
    fprintf(stderr, "USAGE: popen3 [command] [filename]\n");
    exit(1);
  }

  /* Відкриття файла для читання */
  if ((infile = fopen(argv[2], "rt")) == NULL)
  {
    perror("fopen");
    exit(1);
  }

  /* Створення програмного каналу за допомогою системного виклику popen() */
  if ((pipe_fp = popen(argv[1], "w")) == NULL)
  {
    perror("popen");
    exit(1);
  }

  /* Реалізація циклу */
  do {
    fgets(readbuf, 80, infile);
    if (feof(infile)) break;
    fputs(readbuf, pipe_fp);
  } while(!feof(infile));

  fclose(infile);
  pclose(pipe_fp);
  return 0;
}
```
